/* --- BEGIN Variable Definitions ---
LifetimeVars &mut request_queue; LifetimeVars ptr_to_resource; LifetimeVars request_halfway; LifetimeBind &mut RD_rq -> &mut request_queue [contains]; LifetimeBind &mut UD_rq -> &mut request_queue [contains]; LifetimeBind &mut DL_rq -> &mut request_queue [contains];
--- END Variable Definitions --- */
fn main() {
    // requests, resources generated by main thread
    let mut available_resource: u32 = 60;
    let mut request_queue: VecDeque<&mut Request> = VecDeque::new();
    let reads_cnt: u32 = 20;
    let mut RD_rq: Request = Request::new(reads_cnt, RequestType::READ);
    request_queue.push_back(&mut RD_rq);
    let updates_cnt: u32 = 30;
    let mut UD_rq: Request = Request::new(updates_cnt, RequestType::UPDATE);
    request_queue.push_back(&mut UD_rq);
    let deletes_cnt: u32 =50;
    let mut DL_rq: Request = Request::new(deletes_cnt, RequestType::DELETE);
    request_queue.push_back(&mut DL_rq);
    // ..., process requests in multi-threading way ...
    // this might be another thread that deal with request processing ...
    let ptr_to_resource = &mut available_resource;
    let request_halfway = process_requests(&mut request_queue, ptr_to_resource); // !{ Lifetime(<FUNC: process_requests>[&mut request_queue{17:17} *CRPT* temporary reference passed on the fly. Lifetime starts and ends on the same line][&mut RD_rq{7:22} *NAME* Of type &'i mut Request<'i>. Contained inside request_queue so its lifetime also contributed to calculation of 'i. *CRPT* Pushed into queue on line 7. Thus comes into scope and is bound to request_queue. *BODY* Contained in queue and didn't get popped out *DRPT* Even though it might have been popped. But it's not deterministic. So being conservative it's alive until destruction of request_queue][&mut UD_rq{10:22} *NAME* Of type &'i mut Request<'i>. Contained inside request_queue so its lifetime also contributed to calculation of 'i. *CRPT* Pushed into queue on line 10. Thus comes into scope and is bound to request_queue. *BODY* Contained in queue and didn't get popped out *DRPT* Even though it might have been popped. But it's not deterministic. So being conservative it's alive until destruction of request_queue][&mut DL_rq{13:22}*NAME* Of type &'i mut Request<'i>. Contained inside request_queue so its lifetime also contributed to calculation of 'i. *CRPT* Pushed into queue on line 13. Thus comes into scope and is bound to request_queue. *BODY* Contained in queue and didn't get popped out *DRPT* Even though it might have been popped. But it's not deterministic. So being conservative it's alive until destruction of request_queue][ptr_to_resource{16:18}]->[request_halfway{17:18}])}
    if let Some(req) = request_halfway {
        println!("#{} of {} requests are left unprocessed!", req.num_request_left, req.request_type.to_string());
    }
    println!("there are #{} free resource left.", available_resource);
}

fn process_requests<'i,'a>(queue: &'i mut VecDeque<&'i mut Request<'i>>, max_process_unit: &'a mut u32) -> Option<&'i mut Request<'i>>{
    loop {
        let front_request: Option<&mut Request> = queue.pop_front();
        if let Some(request) = front_request{
            // if current max_process_unit is greater than current requests
            if request.num_request_left <= max_process_unit{
                println!("Served #{} of {} requests.", request.num_request_left, request.request_type.to_string());
                // decrement the amount of resource spent on this request
                *max_process_unit = *max_process_unit - *request.num_request_left;
                // signify this request has been processed
                *request.num_request_left = 0;
            }
            // not enough
            else{
                // process as much as we can
                *request.num_request_left = *request.num_request_left - *max_process_unit;
                // sad, no free resource anymore
                *max_process_unit = 0;
                // enqueue the front request back to queue, hoping someone will handle it...
                // queue.push_front(request);
                return Option::Some(request);
            }
            //
        }
        else {
            // no available request to process, ooh-yeah!
            return Option::None;

        }
    }
}
